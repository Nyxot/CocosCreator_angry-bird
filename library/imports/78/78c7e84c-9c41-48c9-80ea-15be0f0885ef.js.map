{
  "version": 3,
  "sources": [
    "unknown"
  ],
  "names": [],
  "mappings": "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",
  "file": "unknown",
  "sourcesContent": [
    "cc.Class({\r\n    extends: cc.Component,\r\n\r\n    properties: {\r\n        // foo: {\r\n        //    default: null,      // The default value will be used only when the component attaching\r\n        //                           to a node for the first time\r\n        //    url: cc.Texture2D,  // optional, default is typeof default\r\n        //    serializable: true, // optional, default is true\r\n        //    visible: true,      // optional, default is true\r\n        //    displayName: 'Foo', // optional\r\n        //    readonly: false,    // optional, default is false\r\n        // },\r\n        // ...\r\n        // Altura del salto del personaje principal\r\n        jumpHeight: 0,\r\n        // Duración del salto del personaje principal\r\n        jumpDuration: 0,\r\n        // Velocidad de movimiento máxima\r\n        maxMoveSpeed: 0,\r\n        // Aceleración\r\n        accel: 0,\r\n        //Si queremo que inicie automaticamente saltando\r\n        Jumpin: true,\r\n    },\r\n\r\n    // use this for initialization\r\n    onLoad: function () {\r\n        this.Jumpin = true;\r\n        /*Iniciando codigo para hacer que nuestro angry brinque sin parar*/\r\n        \r\n        // inicializando accion de salto (jump action)\r\n        this.jumpAction = this.setJumpAction();\r\n        this.node.runAction(this.jumpAction);\r\n        /*Finalizando codigo para hacer que nuestro angry brinque sin parar*/\r\n        \r\n        // cambio de dirección de aceleración (switch of acceleration direction)\r\n        this.accLeft = false;\r\n        this.accRight = false;\r\n        // Velocidad horizontal actual del personaje principal(current horizontal speed of main character)\r\n        this.xSpeed = 0;\r\n\r\n        // Inicializar el receptor de entrada de teclado(initialize keyboard input listener)\r\n        this.setInputControl();\r\n\r\n    },\r\n    setJumpAction: function () {\r\n        // Salto arriva (jump up))\r\n        var jumpUp = cc.moveBy(this.jumpDuration, cc.p(0, this.jumpHeight)).easing(cc.easeCubicActionOut());\r\n        // Salto abajo (jump down)\r\n        var jumpDown = cc.moveBy(this.jumpDuration, cc.p(0, -this.jumpHeight)).easing(cc.easeCubicActionIn());\r\n        // Repetir(repeat)\r\n        if(this.Jumpin == true)\r\n        {return cc.repeatForever(cc.sequence(jumpUp, jumpDown));}\r\n        else {return cc.sequence(jumpUp, jumpDown);}\r\n    },\r\n    setInputControl: function () {\r\n        var self = this;\r\n        // add keyboard event listener\r\n        // agrega el receptor de eventos de teclado\r\n        cc.eventManager.addListener({\r\n            event: cc.EventListener.KEYBOARD,\r\n            // When there is a key being pressed down, judge if it's the designated directional button and set up acceleration in the corresponding direction\r\n            // Cuando se pulsa una tecla, juzga si es el botón direccional designado y configura la aceleración en la dirección correspondiente\r\n            onKeyPressed: function(keyCode, event) {\r\n                switch(keyCode) {\r\n                    case cc.KEY.left:\r\n                        self.accLeft = true;\r\n                        self.accRight = false;\r\n                        break;\r\n                    case cc.KEY.right:\r\n                        self.accLeft = false;\r\n                        self.accRight = true;\r\n                        break;\r\n                    case cc.KEY.up:\r\n                        self.Jumpin = true;\r\n                        self.jumpAction = self.setJumpAction();\r\n                        self.node.runAction(self.jumpAction);\r\n                        break;\r\n                    case cc.KEY.down:\r\n                        //self.Jumpin = false;\r\n                        //self.jumpHeight = 0;\r\n                        //self.jumpAction = self.setJumpAction();\r\n                        //self.node.runAction(self.jumpAction.reverse());\r\n                        break;\r\n                }\r\n            },\r\n            // when releasing the button, stop acceleration in this direction\r\n            // al soltar el botón, detener la aceleración en esta dirección\r\n            onKeyReleased: function(keyCode, event) {\r\n                switch(keyCode) {\r\n                    case cc.KEY.left:\r\n                        self.accLeft = false;\r\n                        break;\r\n                    case cc.KEY.right:\r\n                        self.accRight = false;\r\n                        break;\r\n                }\r\n            }\r\n        }, self.node);\r\n    },\r\n\r\n    update: function (dt) {\r\n        // update speed of each frame according to the current acceleration direction\r\n        // Actualizar velocidad de cada trama de acuerdo con la dirección de aceleración actual\r\n        if (this.accLeft) {\r\n            this.xSpeed -= this.accel * dt;\r\n        } else if (this.accRight) {\r\n            this.xSpeed += this.accel * dt;\r\n        }\r\n        // Restrict the movement speed of the main character to the maximum movement speed\r\n        // Restringir la velocidad de movimiento del personaje principal a la velocidad máxima de movimiento\r\n        if ( Math.abs(this.xSpeed) > this.maxMoveSpeed ) {\r\n            // if speed reaches its limit, use the max speed with current direction\r\n            this.xSpeed = this.maxMoveSpeed * this.xSpeed / Math.abs(this.xSpeed);\r\n        }\r\n\r\n        // Update the position of the main character according to the current speed\r\n        // Actualizar la posición del personaje principal de acuerdo con la velocidad actual\r\n        this.node.x += this.xSpeed * dt;\r\n    },\r\n});\r\n"
  ]
}